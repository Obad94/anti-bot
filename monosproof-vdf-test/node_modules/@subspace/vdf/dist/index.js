var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./vdf"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // @ts-ignore
    const vdf = require("./vdf");
    function CreateLib(lib, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const libInstance = lib(options);
            /**
             * Generate VDF proof
             *
             * @param iterations
             * @param challenge
             * @param intSizeBits
             * @param isPietrzak
             */
            function generate(iterations, challenge, intSizeBits, isPietrzak) {
                if (isPietrzak && (iterations % 2 !== 0 || iterations < 66)) {
                    throw new Error('Number of iterations must be even and at least 66');
                }
                const proofPtr = libInstance.allocatePointer();
                const proofSize = libInstance.allocateBytes(4);
                const challengeBuffer = libInstance.allocateBytes(0, challenge);
                const result = libInstance._generate(iterations, challengeBuffer, challengeBuffer.length, intSizeBits, isPietrzak, proofPtr, proofSize);
                if (result === 0) {
                    const proof = proofPtr.dereference(proofSize.get(Uint32Array)[0]);
                    const proofValue = proof.get();
                    proofPtr.free();
                    proofSize.free();
                    challengeBuffer.free();
                    proof.free();
                    return proofValue;
                }
                else {
                    proofPtr.free();
                    proofSize.free();
                    challengeBuffer.free();
                    throw new Error('Failed to generate proof');
                }
            }
            /**
             * Verify that VDF proof is correct
             *
             * @param iterations
             * @param challenge
             * @param proof
             * @param intSizeBits
             * @param isPietrzak
             */
            function verify(iterations, challenge, proof, intSizeBits, isPietrzak) {
                if (isPietrzak && (iterations % 2 !== 0 || iterations < 66)) {
                    throw new Error('Number of iterations must be even and at least 66');
                }
                const challengeBuffer = libInstance.allocateBytes(0, challenge);
                const proofBuffer = libInstance.allocateBytes(0, proof);
                const result = libInstance._verify(iterations, challengeBuffer, challengeBuffer.length, proofBuffer, proofBuffer.length, intSizeBits, isPietrzak);
                challengeBuffer.free();
                proofBuffer.free();
                return Boolean(result);
            }
            yield new Promise((resolve) => {
                libInstance.then(() => {
                    resolve();
                });
            });
            return {
                _lib_internal: lib,
                generate: generate,
                verify: verify,
            };
        });
    }
    function wrapper(lib) {
        return CreateLib.bind(null, lib);
    }
    exports.default = wrapper(vdf);
});
//# sourceMappingURL=index.js.map